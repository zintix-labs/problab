// Package sampler 提供一系列高效能的加權抽樣演算法與工具。
//
// 本檔案 (shuffle.go) 定義了泛型的洗牌演算法
//
// 適用情境:
// - 就地打亂列表排序
// - 無加權取後不放回的抽樣順序

package sampler

import "github.com/zintix-labs/problab/sdk/core"

// Shuffle 使用 Fisher-Yates (亦稱 Knuth Shuffle) 演算法
// 對泛型切片進行「就地 (In-place)」隨機重排。
//
// 演算法特性：
//
//  1. 公平性 (Unbiased)：
//     此算法保證所有可能的 N! 種排列組合出現的機率是嚴格相等的 (1/N!)。
//     這解決了傳統 "Naive Shuffle" (每個位置都隨機跟任意位置交換) 導致的機率偏差問題。
//
//  2. 效能 (High Performance)：
//     - 時間複雜度：O(N)，只需要對陣列進行一次線性掃描。
//     - 空間複雜度：O(1)，直接在原記憶體位置交換，實現零配置 (Zero Allocation)。
//
// 使用場景：
//
//	適用於任何需要公平洗牌的邏輯，如撲克牌洗牌、滾輪符號隨機排列、抽獎池打亂等。
func Shuffle[T any](c *core.Core, src []T) {
	if len(src) <= 1 {
		return
	}
	// 核心迴圈：從最後一個元素 (n-1) 開始往前遍歷至索引 1。
	//
	// 為什麼只到 i > 0？
	// 因為當 i = 1 時，我們會在 [0, 1] 之間選一個 j。
	// 無論選中 0 還是 1，剩下的最後一個元素 (索引 0) 已經在它該在的位置上了，
	// 無需再單獨對索引 0 執行一次 "0 到 0" 的交換。
	for i := len(src) - 1; i > 0; i-- {
		// 隨機選取一個索引 j，範圍必須是 [0, i] (包含 i 本身)。
		// c.IntN(i + 1) 會回傳 [0, i] 之間的整數。
		//
		// 數學意義：
		// 這代表在當前這一步，位置 i 的元素是從「尚未洗牌的部分 (0...i)」中隨機選出的。
		// 一旦選定並交換到位置 i，該位置就被「鎖定」，不再參與後續的交換，
		// 這是 Fisher-Yates 算法能保證均勻分佈的關鍵。
		j := c.IntN(i + 1)
		src[i], src[j] = src[j], src[i]
	}
}
